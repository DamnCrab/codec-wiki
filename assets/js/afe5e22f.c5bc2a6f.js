"use strict";(self.webpackChunkcodec_wiki=self.webpackChunkcodec_wiki||[]).push([[8117],{9765:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var t=n(4848),r=n(8453);const s={title:"x265",sidebar_position:2},o="x265",a={id:"encoders/x265",title:"x265",description:"x265 is a software library and command line application for encoding H.265 / HEVC developed by MulticoreWare, written in C++ and x86 assembly, and released in 2013.",source:"@site/docs/encoders/x265.mdx",sourceDirName:"encoders",slug:"/encoders/x265",permalink:"/docs/encoders/x265",draft:!1,unlisted:!1,editUrl:"https://github.com/av1-community-contributors/codec-wiki/tree/main/docs/encoders/x265.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"x265",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"x264",permalink:"/docs/encoders/x264"},next:{title:"x266",permalink:"/docs/encoders/x266"}},l={},d=[{value:"FFmpeg",id:"ffmpeg",level:2},{value:"Installation",id:"installation",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Preset",id:"preset",level:3},{value:"CRF",id:"crf",level:3},{value:"bframes",id:"bframes",level:3},{value:"SAO",id:"sao",level:3},{value:"Deblock",id:"deblock",level:3},{value:"Psy-RD",id:"psy-rd",level:3},{value:"Adaptive Quantization",id:"adaptive-quantization",level:3},{value:"CU-Tree",id:"cu-tree",level:3}];function c(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"x265",children:"x265"}),"\n",(0,t.jsxs)(i.p,{children:["x265 is a software library and command line application for encoding ",(0,t.jsx)(i.a,{href:"/docs/video/HEVC",children:"H.265 / HEVC"})," developed by MulticoreWare, written in C++ and x86 assembly, and released in 2013."]}),"\n",(0,t.jsx)(i.p,{children:"By default, x265 is tuned for low-bitrate content due to the blurring filters it applies. However, it can be tuned using CLI options to be very effective for high-fidelity content as well.\nIt is a more efficient and modern encoder compared to x264, and is currently a popular choice for both high-fidelity and mini encodes."}),"\n",(0,t.jsx)(i.p,{children:"x265 is currently not recommended for lossless encoding. For that niche, x264 is considerably faster without meaningful efficiency loss."}),"\n",(0,t.jsx)(i.h2,{id:"ffmpeg",children:"FFmpeg"}),"\n",(0,t.jsxs)(i.p,{children:["x265 is available in FFmpeg via ",(0,t.jsx)(i.code,{children:"libx265"}),", to check if you have it, run ",(0,t.jsx)(i.code,{children:"ffmpeg -h encoder=libx265"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"installation",children:"Installation"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Pre-built binary (Recommended):"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"http://msystem.waw.pl/x265/",children:"http://msystem.waw.pl/x265/"})}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(i.p,{children:["This section will overview the most important parameters for controlling output and quality in x265. The parameters will be listed in the format used by the standalone x265 binary,\nbut all of the parameters should also be usable in ffmpeg in the format e.g. ",(0,t.jsx)(i.code,{children:"-x265-params pass=1"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"preset",children:"Preset"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"--preset slow"})}),"\n",(0,t.jsxs)(i.p,{children:["If encoding speed is a priority, x265 is probably not the best choice. x264 at ",(0,t.jsx)(i.code,{children:"--preset veryslow"})," will likely be faster than x265 at ",(0,t.jsx)(i.code,{children:"--preset fast"}),", while providing comparable efficiency.\nHowever, x265 finds its sweet spot at ",(0,t.jsx)(i.code,{children:"--preset slow"}),", and this is the preset most people should use. This preset provides high quality while not being unreasonably slow."]}),"\n",(0,t.jsxs)(i.p,{children:["The exception where you may want to tax your CPU by going to ",(0,t.jsx)(i.code,{children:"--preset veryslow"})," is when doing lower bitrate encodes (e.g. crf >=22). This is because the ",(0,t.jsx)(i.code,{children:"veryslow"})," preset provides\nbetter motion estimation at low bitrates. However, it is exceptionally slow, so it is not generally recommended for everyday use."]}),"\n",(0,t.jsx)(i.h3,{id:"crf",children:"CRF"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"--crf"})}),"\n",(0,t.jsx)(i.p,{children:"CRF, standing for Constant Rate Factor, is a method for selecting a level of quality-to-filesize tradeoff. CRF is preferable to bitrate targeting because CRF only requires one encoding pass,\nso bitrate targeting should only be used if you need to target a specific filesize. Nowadays, those situations are uncommon and it is preferred to use CRF to target a quality level.\nCRF is preferable to QP because CRF allows the encoder to vary the quality level from frame to frame for better viewing quality in areas of the video that need it the most."}),"\n",(0,t.jsx)(i.p,{children:'What CRF to use will vary depending on your goals. The range of valid CRF values is 0-51, with larger values providing smaller filesize but lower quality. Some amount of experimentation\nmay be needed to find the value you prefer. A decent "balanced" target will be around 17 or 18, providing good quality without inflating filesize too much. For a focus on maximum quality,\na value of 12 or 13 will result in visually lossless output for most videos, but will result in a much larger filesize. For miniature encodes, try raising the CRF as much as you feel comfortable\nbefore the quality becomes unbearable. CRFs of 22 or higher are generally considered "low bitrate", so how high you raise the CRF depends on how low of a filesize you are trying to achieve.'}),"\n",(0,t.jsx)(i.h3,{id:"bframes",children:"bframes"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"--bframes"})}),"\n",(0,t.jsxs)(i.p,{children:["B-frames are bi-directional predictive frames, this means that they can reference frames both before and after themselves, which makes them very efficient.\nThe ",(0,t.jsx)(i.code,{children:"--bframes"})," parameter controls how many B-frames can be used consecutively. Higher values can result in better compression, but this value has diminishing returns,\nas the encoder won't use extra B-frames in situations where it would reduce efficiency."]}),"\n",(0,t.jsxs)(i.p,{children:["The default value at preset slow is ",(0,t.jsx)(i.code,{children:"4"}),". It is recommended to increase this to ",(0,t.jsx)(i.code,{children:"--bframes 5"})," for live action and CGI content, or ",(0,t.jsx)(i.code,{children:"--bframes 8"})," for anime and cartoons.\nContent with little motion benefits more from high B-frames values, but even on anime where there are many still scenes, there is no measurable benefit\nto using a value higher than ",(0,t.jsx)(i.code,{children:"8"}),", and it would just slow down the encoder for no benefit."]}),"\n",(0,t.jsx)(i.h3,{id:"sao",children:"SAO"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"--sao"}),", ",(0,t.jsx)(i.code,{children:"--limit-sao"}),", ",(0,t.jsx)(i.code,{children:"--no-sao"})]}),"\n",(0,t.jsxs)(i.p,{children:["SAO stands for Sample Adaptive Offset, and is a loop filter used by x265 to prevent artifacting. However, it has the side effect of losing sharpness on details.\nIt is recommended to leave this on (default) at high CRF values (>=22). For medium values between 17-21, you can use ",(0,t.jsx)(i.code,{children:"--limit-sao"})," which will limit the effects of SAO to have\nless of a significant effect. For low CRF values (<=16), you can safely use ",(0,t.jsx)(i.code,{children:"--no-sao"})," to prefer detail preservation, as the higher bitrates will naturally lead to fewer artifacts."]}),"\n",(0,t.jsx)(i.h3,{id:"deblock",children:"Deblock"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"--deblock"})}),"\n",(0,t.jsxs)(i.p,{children:["Deblock is another loop filter, this one intended to reduce blocking in videos, but may have a blurring effect at high strengths. For most encodes, it is fine to leave this\nat the default value. At lower CRF values, it may be desirable to lower this to ",(0,t.jsx)(i.code,{children:"--deblock -1:-1"})," for anime or ",(0,t.jsx)(i.code,{children:"--deblock -2:-2"})," for live action, in order to preserve\nmore grain and detail."]}),"\n",(0,t.jsx)(i.h3,{id:"psy-rd",children:"Psy-RD"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"--psy-rd"})," and ",(0,t.jsx)(i.code,{children:"--psy-rdoq"})]}),"\n",(0,t.jsx)(i.p,{children:"The parameters control psychovisual rate distribution. What this means is the redistribution of bits to make a video more pleasing to human eyes. These options may be harmful to metrics\nthat compare videos mathematically, but are better for viewing human eyes because they prioritize facets of the video that humans prefer."}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"--psy-rd"})," biases toward matching the level of energy in the source image, which makes it good for retaining detail. For standard anime, it is recommended to use ",(0,t.jsx)(i.code,{children:"--psy-rd 1.0"}),". The more\ngrain, detail, and dark scenes in a source, the higher this should be raised. Many modern anime tends to have more detailed backgrounds and surfaces, so ",(0,t.jsx)(i.code,{children:"--psy-rd 1.5"})," may be a better\ndefault for modern anime. For live action, a ",(0,t.jsx)(i.code,{children:"--psy-rd 1.5"})," or possibly even ",(0,t.jsx)(i.code,{children:"2.0"})," may be preferred, as live action naturally has more detail and grain than anime."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"--psy-rdoq"})," biases toward energy in general, which makes it key for preserving grain. ",(0,t.jsx)(i.code,{children:"--psy-rdoq 1.0"})," is a safe default for anime. Like psy-rd, this value should be increased more\nfor sources with more grain. For grainy anime, ",(0,t.jsx)(i.code,{children:"--psy-rdoq 2.0"})," or even ",(0,t.jsx)(i.code,{children:"3.0"})," can be preferable. Likewise, for many live action series, a default of ",(0,t.jsx)(i.code,{children:"--psy-rdoq 3.0"})," can be preferable,\nor even ",(0,t.jsx)(i.code,{children:"4.0"})," with heavy grain."]}),"\n",(0,t.jsx)(i.p,{children:"These are two settings that should be tweaked according to the source material."}),"\n",(0,t.jsx)(i.h3,{id:"adaptive-quantization",children:"Adaptive Quantization"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"--aq-mode 3 --aq-strength <variable>"})}),"\n",(0,t.jsxs)(i.p,{children:["Adaptive quantization, shortened to AQ, is a mechanism to redistribute bitrate within a frame to improve visual quality by reducing artifacts.\nx265 has several different AQ modes, and ",(0,t.jsx)(i.code,{children:"--aq-mode 3"})," is nearly always best, because this mode adds a bias favoring dark scenes, which greatly reduces the effects of banding and blocking.\nThe strength of AQ can also be set with ",(0,t.jsx)(i.code,{children:"--aq-strength"}),". The optimal setting for this may vary depending on the type of content you are encoding.\nFor anime, ",(0,t.jsx)(i.code,{children:"--aq-strength 0.7"})," will typically produce good results. For live action, a slightly higher ",(0,t.jsx)(i.code,{children:"0.8"})," may be a better default.\nHigher values, up to ",(0,t.jsx)(i.code,{children:"--aq-strength 1"}),", can be helpful for sources with heavy grain, although this will also increase overall bitrate."]}),"\n",(0,t.jsx)(i.h3,{id:"cu-tree",children:"CU-Tree"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"--no-cutree"})}),"\n",(0,t.jsxs)(i.p,{children:["CU-Tree is a mechanism very similar to MB-Tree in x264, which is intended to redistribute bitrate in a more optimal psychovisual manner. However, many people find CU-Tree to be harmful to quality,\nespecially when attempting to encode videos with considerable amounts of grain, and therefore many people recommend disabling this with ",(0,t.jsx)(i.code,{children:"--no-cutree"}),"."]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var t=n(6540);const r={},s=t.createContext(r);function o(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);