"use strict";(self.webpackChunkcodec_wiki=self.webpackChunkcodec_wiki||[]).push([[4931],{9530:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>c,toc:()=>u});var t=i(5893),r=i(1151),s=i(4866),o=i(5162);const a={label:"SVT-AV1",sidebar_position:4},l="SVT-AV1",c={id:"encoders/SVT-AV1",title:"SVT-AV1",description:"The content in this entry is incomplete & is in the process of being completed.",source:"@site/docs/encoders/SVT-AV1.mdx",sourceDirName:"encoders",slug:"/encoders/SVT-AV1",permalink:"/docs/encoders/SVT-AV1",draft:!1,unlisted:!1,editUrl:"https://github.com/av1-community-contributors/codec-wiki/tree/main/docs/encoders/SVT-AV1.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{label:"SVT-AV1",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"vpxenc",permalink:"/docs/encoders/vpxenc"},next:{title:"rav1e",permalink:"/docs/encoders/rav1e"}},d={},u=[{value:"FFmpeg",id:"ffmpeg",level:2},{value:"Building",id:"building",level:2},{value:"Encoding",id:"encoding",level:2},{value:"Strengths",id:"strengths",level:3},{value:"Weaknesses",id:"weaknesses",level:3},{value:"Encoder Optimization",id:"encoder-optimization",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"svt-av1",children:"SVT-AV1"}),"\n",(0,t.jsx)(n.admonition,{title:"Under Maintenance",type:"info",children:(0,t.jsx)(n.p,{children:"The content in this entry is incomplete & is in the process of being completed."})}),"\n",(0,t.jsx)(n.p,{children:"SVT-AV1 (Scalable Video Technology for AV1) is an AV1-compliant software encoder/decoder library. Jointly developed by Intel and Netflix, SVT-AV1 is written almost entirely in C with some parts written in C++ and Assembly."}),"\n",(0,t.jsxs)(n.p,{children:['This entry discusses the SVT-AV1 encoder, also known as the "Production" AV1 encoder (while ',(0,t.jsx)(n.a,{href:"/docs/encoders/aomenc",children:"aomenc"}),' is the "reference" AV1 encoder), & refers to SVT-AV1 as such. SVT-AV1 is known for its parallelization, high coding efficiency, & active development. SVT-AV1 scales across multiple CPU cores much more effectively than aomenc or ',(0,t.jsx)(n.a,{href:"/docs/encoders/rav1e",children:"rav1e"}),", so the use of tools like ",(0,t.jsx)(n.a,{href:"/docs/utilities/av1an",children:"Av1an"})," is less helpful while still being helpful for scene detection."]}),"\n",(0,t.jsx)(n.h2,{id:"ffmpeg",children:"FFmpeg"}),"\n",(0,t.jsxs)(n.p,{children:["SVT-AV1 is available in FFmpeg via ",(0,t.jsx)(n.code,{children:"libsvtav1"}),", to check if you have it, run ",(0,t.jsx)(n.code,{children:"ffmpeg -h encoder=libsvtav1"}),". You can input non-FFmpeg standard SVT-AV1 parameters via ",(0,t.jsx)(n.code,{children:"-svtav1-params"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"building",children:"Building"}),"\n",(0,t.jsxs)(s.Z,{children:[(0,t.jsxs)(o.Z,{value:"unixlike",label:"Linux & macOS",children:[(0,t.jsxs)(n.p,{children:["A precompiled AVX2-optimized binary can be installed for x86_64 Linux via ",(0,t.jsx)(n.a,{href:"/docs/utilities/rav1ator-cli",children:"rAV1ator CLI"}),". However, it is always recommended to build from source."]}),(0,t.jsx)(n.p,{children:"To build SVT-AV1 from source, clone the official SVT-AV1 repository from Gitlab & build from source."}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"git clone https://gitlab.com/AOMediaCodec/SVT-AV1/\r\ncd SVT-AV1/Build/linux\r\n./build.sh release\n"})}),(0,t.jsxs)(n.p,{children:["The compiled binaries will be in the Bin/Release directory, including SvtAv1EncApp. You can also add the ",(0,t.jsx)(n.code,{children:"no-dec"})," flag to skip building SvtAv1DecApp if you don't need it to save on some compilation time."]}),(0,t.jsxs)(n.p,{children:["If you'd like to build from the latest release (1.8.0 at the time of writing - last updated 29 Dec 2023) please do ",(0,t.jsx)(n.code,{children:"git reset --hard 59645eea34e2815b627b8293aa3af254eddd0d69"})," in the cloned directory. It is recommended that you do this, as new changes to git aren't always stable right away & a release will guarantee more stability."]}),(0,t.jsxs)(n.p,{children:["If you want extra performance, it is possible to build SVT-AV1 using PGO (Profile-guided Optimization). ",(0,t.jsxs)(n.strong,{children:["Be aware that this particular script infers that you have a .y4m file (or multiple) in ",(0,t.jsx)(n.code,{children:"/dev/shm"})," for transcoding"]}),". You can compile statically linked SVT-AV1 with PGO by following this script:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"git clone https://gitlab.com/AOMediaCodec/SVT-AV1/\r\ncd SVT-AV1/Build/linux\r\n./build.sh cc=gcc cxx=g++ enable-lto enable-pgo static native jobs=$(nproc) pgo-dir=/dev/shm pgo-videos=/dev/shm release\n"})}),(0,t.jsx)(n.p,{children:"If you wish to store videos elsewhere or provide custom parameters to the SvtAv1EncApp binary, try this script:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"git clone https://gitlab.com/AOMediaCodec/SVT-AV1/\r\ncd SVT-AV1/Build/linux\r\n./build.sh cc=gcc cxx=g++ enable-lto enable-pgo static native jobs=$(nproc) pgo-dir=/dev/shm pgo-compile-gen release\r\n../../Bin/Release/SvtAv1EncApp # Run this binary as many times as you'd like with arguments of your choice to collect data\r\n./build.sh cc=gcc cxx=g++ enable-lto enable-pgo static native jobs=$(nproc) pgo-dir=/dev/shm pgo-compile-use release\n"})})]}),(0,t.jsx)(o.Z,{value:"windows",label:"Windows",children:(0,t.jsxs)(n.p,{children:["To be filled. If you believe you can help, see our ",(0,t.jsx)(n.a,{href:"/docs/contribution-guide",children:"Contribution Guide"}),"."]})})]}),"\n",(0,t.jsx)(n.h2,{id:"encoding",children:"Encoding"}),"\n",(0,t.jsx)(n.h3,{id:"strengths",children:"Strengths"}),"\n",(0,t.jsx)(n.p,{children:"SVT-AV1's greatest strength is its parallelization capability, where it outclasses other AV1 encoders by a significant margin. SVT-AV1's parallelization techniques do not involve tiling & don't harm video quality, & can comfortably utilize up to 16 cores given standard 1080p video. This is while maintaining competitive coding efficiency to rav1e. Both are outperformed by well-tuned aomenc, as the reference encoder has a more complete AV1 implementation."}),"\n",(0,t.jsx)(n.h3,{id:"weaknesses",children:"Weaknesses"}),"\n",(0,t.jsxs)(n.p,{children:["SVT-AV1 is strongest on x86 CPUs, & while ARM NEON assembly is ",(0,t.jsx)(n.a,{href:"https://gitlab.com/AOMediaCodec/SVT-AV1/-/commit/ba13fac241f1b54954935f2cb200efc07f3de13a",children:"available"})," since v1.8.0, SVT-AV1 still underperforms on ARM. For this reason, it is not a good cross-architecture CPU benchmark. SVT-AV1's support for various AV1 features is also limited; it only supports up to 4:2:0 chroma subsampling with no support for 12-bit color, and it does not support scene change detection (there are no plans to implement this, either)."]}),"\n",(0,t.jsx)(n.h3,{id:"encoder-optimization",children:"Encoder Optimization"}),"\n",(0,t.jsxs)(n.p,{children:["Aside from build optimizations for speed, there is further tweaking to be done to the ",(0,t.jsx)(n.code,{children:"SvtAv1EncApp"})," binary parameters when encoding."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--film-grain"})," & ",(0,t.jsx)(n.code,{children:"--film-grain-denoise"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Most live-action sources feature hard-to-compress digital noise that is easily smoothed out by AV1 compression. To add this grain back, or even denoise through the encoder and then add grain, it is possible to use the ",(0,t.jsx)(n.code,{children:"--film-grain"})," parameter to specify an amount of film grain to add to the encode (& ",(0,t.jsx)(n.code,{children:"--film-grain-denoise"})," to specify how to denoise the input video before encoding for potentially better appeal). Denoising a video always removes fine details, so sticking with just ",(0,t.jsx)(n.code,{children:"--film-grain"})," is recommended in most cases. According to ",(0,t.jsx)(n.a,{href:"https://gitlab.com/AOMediaCodec/SVT-AV1/-/blob/master/Docs/CommonQuestions.mdx#practical-advice-on-grain-synthesis",children:"SVT-AV1 documentation"}),", a level of 8 should be used for live-action content with a normal amount of grain while a level of 4 works well for hand-drawn animation or other smoother-looking sources that still stand to benefit from some grain synthesis."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"--input-depth 10"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"10-bit output from AV1 encoding is always desirable for coding efficiency, even if your source is 8-bit."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"--tune 2"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["There are three tunes in SVT-AV1: Tune 1 is for ",(0,t.jsx)(n.a,{href:"/docs/metrics/PSNR",children:"PSNR"})," ",(0,t.jsx)(n.a,{href:"/docs/introduction/psychovisual",children:"RDO"}),", Tune 2 is for ",(0,t.jsx)(n.a,{href:"/docs/metrics/SSIM",children:"SSIM"})," RDO, & Tune 0 is a ",(0,t.jsx)(n.a,{href:"/docs/introduction/psychovisual",children:"psychovisual"})," tune labeled VQ. It has been common practice to lean away from the PSNR tune, as it is not designed for visual quality but rather to perform better on the PSNR metric which is widely considered to be inconsistent with our human perception of fidelity. Using the VQ tune is a safe bet for now, but many believe the newer SSIM tune provides better visual fidelity. This is anecdotal, & has yet to be meaningfully proven"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"--enable-overlays 1"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Enables overlay pictures to be used as additional reference frames for the referenced picture, disabled by default. Improves coding efficiency."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"--keyint [FPS*10]"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Similar to ",(0,t.jsx)(n.code,{children:"--kf-max-dist"})," in ",(0,t.jsx)(n.a,{href:"/docs/encoders/vpxenc",children:"vpxenc"}),", this tells the encoder when to place keyframes. Because SVT-AV1 doesn't have scene detection, this isn't the maximum distance between keyframes, but rather a fixed interval for placing keyframes."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"--irefresh-type 2"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Intra refresh is specified through this option, & lets the user decide between Closed GOP & Open GOP. GOP stands for Group of Pictures. Open GOP allows GOPs to ",(0,t.jsx)(n.a,{href:"https://ottverse.com/closed-gop-open-gop-idr/",children:"reference one another"}),", but support for this feature is currently incomplete. Therefore, it is recommended to use Closed GOP for the time being via ",(0,t.jsx)(n.code,{children:"--irefresh-type 2"})," until this is rectified."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"--preset X"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"SVT-AV1 can be used in 14 different presets, labeled 0 through 13. Preset 0 is the slowest, but provides the best coding efficiency; Preset 13 is the fastest. Using presets 2 through 8 is the best course of action for non-realtime applications."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"--crf X"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"CRF is the best way to target quality for optimal visual fidelity. VBR & CBR lose efficiency due to their inherently limited rate control."})]})}function p(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},5162:(e,n,i)=>{i.d(n,{Z:()=>o});i(7294);var t=i(6905);const r={tabItem:"tabItem_Ymn6"};var s=i(5893);function o(e){let{children:n,hidden:i,className:o}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,t.Z)(r.tabItem,o),hidden:i,children:n})}},4866:(e,n,i)=>{i.d(n,{Z:()=>j});var t=i(7294),r=i(6905),s=i(2466),o=i(6550),a=i(469),l=i(1980),c=i(7392),d=i(12);function u(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:i}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return u(e).map((e=>{let{props:{value:n,label:i,attributes:t,default:r}}=e;return{value:n,label:i,attributes:t,default:r}}))}(i);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,i])}function p(e){let{value:n,tabValues:i}=e;return i.some((e=>e.value===n))}function f(e){let{queryString:n=!1,groupId:i}=e;const r=(0,o.k6)(),s=function(e){let{queryString:n=!1,groupId:i}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return i??null}({queryString:n,groupId:i});return[(0,l._X)(s),(0,t.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(r.location.search);n.set(s,e),r.replace({...r.location,search:n.toString()})}),[s,r])]}function m(e){const{defaultValue:n,queryString:i=!1,groupId:r}=e,s=h(e),[o,l]=(0,t.useState)((()=>function(e){let{defaultValue:n,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:i}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${i.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=i.find((e=>e.default))??i[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:s}))),[c,u]=f({queryString:i,groupId:r}),[m,b]=function(e){let{groupId:n}=e;const i=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,s]=(0,d.Nk)(i);return[r,(0,t.useCallback)((e=>{i&&s.set(e)}),[i,s])]}({groupId:r}),g=(()=>{const e=c??m;return p({value:e,tabValues:s})?e:null})();(0,a.Z)((()=>{g&&l(g)}),[g]);return{selectedValue:o,selectValue:(0,t.useCallback)((e=>{if(!p({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),b(e)}),[u,b,s]),tabValues:s}}var b=i(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=i(5893);function x(e){let{className:n,block:i,selectedValue:t,selectValue:o,tabValues:a}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.o5)(),d=e=>{const n=e.currentTarget,i=l.indexOf(n),r=a[i].value;r!==t&&(c(n),o(r))},u=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const i=l.indexOf(e.currentTarget)+1;n=l[i]??l[0];break}case"ArrowLeft":{const i=l.indexOf(e.currentTarget)-1;n=l[i]??l[l.length-1];break}}n?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":i},n),children:a.map((e=>{let{value:n,label:i,attributes:s}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:t===n?0:-1,"aria-selected":t===n,ref:e=>l.push(e),onKeyDown:u,onClick:d,...s,className:(0,r.Z)("tabs__item",g.tabItem,s?.className,{"tabs__item--active":t===n}),children:i??n},n)}))})}function y(e){let{lazy:n,children:i,selectedValue:r}=e;const s=(Array.isArray(i)?i:[i]).filter(Boolean);if(n){const e=s.find((e=>e.props.value===r));return e?(0,t.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:s.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function V(e){const n=m(e);return(0,v.jsxs)("div",{className:(0,r.Z)("tabs-container",g.tabList),children:[(0,v.jsx)(x,{...e,...n}),(0,v.jsx)(y,{...e,...n})]})}function j(e){const n=(0,b.Z)();return(0,v.jsx)(V,{...e,children:u(e.children)},String(n))}},1151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>o});var t=i(7294);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);