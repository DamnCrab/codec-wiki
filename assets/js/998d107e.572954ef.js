"use strict";(self.webpackChunkcodec_wiki=self.webpackChunkcodec_wiki||[]).push([[274],{7672:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>a});var o=n(4848),r=n(8453);const s={title:"FFV1",sidebar_position:12},t="FFV1",c={id:"video/FFV1",title:"FFV1",description:"This section is in need of contributions. If you believe you can help, please see our Contribution Guide to get started as a contributor!",source:"@site/docs/video/FFV1.mdx",sourceDirName:"video",slug:"/video/FFV1",permalink:"/docs/video/FFV1",draft:!1,unlisted:!1,editUrl:"https://github.com/av1-community-contributors/codec-wiki/tree/main/docs/video/FFV1.mdx",tags:[],version:"current",sidebarPosition:12,frontMatter:{title:"FFV1",sidebar_position:12},sidebar:"tutorialSidebar",previous:{title:"Theora",permalink:"/docs/video/Theora"},next:{title:"UT Video",permalink:"/docs/video/utvideo"}},d={},a=[{value:"History",id:"history",level:2},{value:"Usage",id:"usage",level:2},{value:"Options",id:"options",level:3},{value:"intra-frame only catch",id:"intra-frame-only-catch",level:2}];function l(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"ffv1",children:"FFV1"})}),"\n",(0,o.jsx)(i.admonition,{title:"Help Wanted",type:"danger",children:(0,o.jsxs)(i.p,{children:["This section is in need of contributions. If you believe you can help, please see our ",(0,o.jsx)(i.a,{href:"/docs/contribution-guide",children:"Contribution Guide"})," to get started as a contributor!"]})}),"\n",(0,o.jsxs)(i.p,{children:["FFV1 (",(0,o.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc9043",children:"rfc9043"}),") is a lossless intra-frame video codec designed for archival use & preservation. Created by Michael Niedermayer it is part of the ",(0,o.jsx)(i.a,{href:"/docs/utilities/ffmpeg",children:"FFmpeg"})," project. The codec supports wide range of color spaces. It can work with YUV and RGB content also including alpha channel with color depths ranging from 8 to 16 bits (only up to 14 in case of RGB). It has good parallelization support and achieves very high compression ratios compared to other lossless video encoders such as ",(0,o.jsx)(i.a,{href:"/docs/video/utvideo",children:"UT Video"})," albeit at the cost of being more resource hungry."]}),"\n",(0,o.jsx)(i.h2,{id:"history",children:"History"}),"\n",(0,o.jsx)(i.p,{children:"In 2003 the codec was merged into FFmpeg however the bistream specification was frozen in 2006 (officially FFV1 version 0). Later in 2009 came version 1 covering more bideo bit depths."}),"\n",(0,o.jsx)(i.p,{children:"Version 2 never got its release, it existed only in experimental form."}),"\n",(0,o.jsx)(i.p,{children:"The 3rd bistream version was frozen in 2013 and it's still the latest as of 2024. It added multithreading support and frame integrity checking."}),"\n",(0,o.jsxs)(i.p,{children:["There is a 4th version ",(0,o.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/draft-ietf-cellar-ffv1-v4/",children:"coming"})," which might bring better support for color spaces, compression improvements and ",(0,o.jsx)(i.a,{href:"https://mailarchive.ietf.org/arch/msg/cellar/gFydpu8BKAgzspvy6Mvbpsrg5yY/",children:"maybe"})," proper inter-frame prediction."]}),"\n",(0,o.jsx)(i.h2,{id:"usage",children:"Usage"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-bash",metastring:'title="Fast, heavily multithreaded"',children:"ffmpeg -i input.mkv -c:v ffv1 -slices 16 out.mkv\n"})}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-bash",metastring:'title="Slow, highest compression"',children:"ffmpeg -i input.mkv -c:v ffv1 -g 60 -slices 4 -context 1 -coder 2 out.mkv\n"})}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-bash",metastring:'title="Recommended for archival purposes, high compression, multithreaded"',children:"ffmpeg -i input.mkv -c:v ffv1 -g 1 -slices 16 -slicecrc 1 -context 1 -coder 2 out.mkv\n"})}),"\n",(0,o.jsx)(i.h3,{id:"options",children:"Options"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"slices"})," - Slices divide frame into multiple parts that can be encoded and decoded in parallel. Can only be one of: [",(0,o.jsx)(i.code,{children:"4"}),", ",(0,o.jsx)(i.code,{children:"6"}),", ",(0,o.jsx)(i.code,{children:"9"}),", ",(0,o.jsx)(i.code,{children:"12"}),", ",(0,o.jsx)(i.code,{children:"16"}),", ",(0,o.jsx)(i.code,{children:"24"}),", ",(0,o.jsx)(i.code,{children:"30"}),"] where ",(0,o.jsx)(i.code,{children:"4"})," is the default."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"slicecrc"})," - Setting it to ",(0,o.jsx)(i.code,{children:"1"})," will enable decoder to detect errors in the bitstream. Must be enabled for archival use. Can be eitner ",(0,o.jsx)(i.code,{children:"0"})," or ",(0,o.jsx)(i.code,{children:"1"}),"."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"context"})," - Setting it to ",(0,o.jsx)(i.code,{children:"1"})," will make encoder use larger context size which usually leads to better compression. Can be eitner ",(0,o.jsx)(i.code,{children:"0"})," or ",(0,o.jsx)(i.code,{children:"1"}),"."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"coder"})," - Sets entropy coding method:","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"0"})," - Golomb-Rice (faster, default)"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"1"})," - Range Coder (used for higher bit depths and better compression)"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"2"})," - Range Coder with custom state transition table (almost the same as ",(0,o.jsx)(i.code,{children:"1"}),")"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"g"})," - Sets ",(0,o.jsx)(i.code,{children:"GOP size"}),". Must be ",(0,o.jsx)(i.code,{children:"1"})," for archival use. ",(0,o.jsx)(i.a,{href:"#intra-frame-only-catch",children:"see below"})]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"intra-frame-only-catch",children:"intra-frame only catch"}),"\n",(0,o.jsxs)(i.p,{children:["Intra-frame only codecs do not use common ",(0,o.jsx)(i.em,{children:"inter"}),"-frame video coding techniques such as ",(0,o.jsx)(i.a,{href:"#TODO",children:"motion compensation"}),", reusing parts of surrounding frames or adapting encoding context based on them. Every frame is independent from one another. Common Intra-frame only codecs may include Motion JPEG (Lossy), Motion JPEG 2000 (Both) or ",(0,o.jsx)(i.a,{href:"/docs/video/utvideo",children:"UT Video"})," (Lossless)."]}),"\n",(0,o.jsxs)(i.p,{children:["If you're careful reader you might have noticed that setting ",(0,o.jsx)(i.code,{children:"GOP size"})," isn't a common characteristic amongst intra-frame only codecs."]}),"\n",(0,o.jsxs)(i.p,{children:["In fact FFV1 can be considered an intra-frame codec only if ",(0,o.jsx)(i.code,{children:"GOP size"})," is set to ",(0,o.jsx)(i.code,{children:"1"}),". When it's larger than that, its context model depends on other frames found within the ",(0,o.jsx)(i.code,{children:"GOP"})," which contradicts the definition of intra-frame only codec. The main reason why it's strongly recommended to set ",(0,o.jsx)(i.code,{children:"GOP size"})," to ",(0,o.jsx)(i.code,{children:"1"})," for archival purposes is that if one frame gets somehow corrupted, we only lost one frame. If ",(0,o.jsx)(i.code,{children:"GOP size"})," was big we could loose much larger part of the video."]}),"\n",(0,o.jsx)(i.p,{children:"References:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/FFV1",children:"Wikipedia"})}),"\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc9043",children:"RFC9043"})}),"\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.a,{href:"https://trac.ffmpeg.org/wiki/Encode/FFV1",children:"FFmpeg Docs"})}),"\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.a,{href:"https://forum.shotcut.org/t/exporting-as-ffv1-change-form-to-support-lossless-parameters/41230/19?page=2",children:"This Thread"})}),"\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.a,{href:"https://video.stackexchange.com/questions/24874/what-does-the-context-parameter-mean-when-using-ffv1-in-ffmpeg",children:"This Question"})}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>c});var o=n(6540);const r={},s=o.createContext(r);function t(e){const i=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),o.createElement(s.Provider,{value:i},e.children)}}}]);