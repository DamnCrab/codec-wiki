"use strict";(self.webpackChunkav_1_wiki=self.webpackChunkav_1_wiki||[]).push([[1034],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),u=s(n),m=i,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p[u]="string"==typeof e?e:i,r[1]=p;for(var s=2;s<o;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8290:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>p,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const o={title:"VVenC"},r="VVenC",p={unversionedId:"encoders/VVenC",id:"encoders/VVenC",title:"VVenC",description:"`vvencapp` spamming the terminal output with progress per-picture-order-count cause god knows why.",source:"@site/docs/encoders/VVenC.md",sourceDirName:"encoders",slug:"/encoders/VVenC",permalink:"/av1-wiki.github.io/docs/encoders/VVenC",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/encoders/VVenC.md",tags:[],version:"current",frontMatter:{title:"VVenC"},sidebar:"tutorialSidebar",previous:{title:"VTM",permalink:"/av1-wiki.github.io/docs/encoders/VTM"},next:{title:"aomenc",permalink:"/av1-wiki.github.io/docs/encoders/aomenc"}},l={},s=[{value:"Installation",id:"installation",level:2},{value:"FFmpeg Integration",id:"ffmpeg-integration",level:2},{value:"Usage",id:"usage",level:2},{value:"Muxing",id:"muxing",level:2},{value:"VVdeC",id:"vvdec",level:2},{value:"Installation",id:"installation-1",level:3},{value:"Decoding",id:"decoding",level:2}],c={toc:s},u="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"vvenc"},"VVenC"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://cdn.discordapp.com/attachments/778167033401049098/1105480788067225710/VVenC_Spam.png",alt:"``vvencapp`` spamming the terminal output with progress per-picture-order-count cause god knows why."})),(0,i.kt)("p",null,"VVenC is an open source command line application for encoding H.266/VVC written in C++ and developed by Fraunhofer Heinrich-Hertz-Institute (HHI)."),(0,i.kt)("admonition",{title:"General support",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"There is currently no need for encoding VVC unless you are into bleeding edge codecs, a developer, video engineer, experimentations, academic papers, or an employee at Fraunhofer HHI. The general public won't bother if they can't play it on their crappy TV set top boxes.")),(0,i.kt)("h2",{id:"installation"},"Installation"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Arch Linux users:")," Check AUR."),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Compilation requires CMake")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The following build procedure should work across all common operating systems")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/fraunhoferhhi/vvenc.git\ncd vvenc\nmkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release\ncmake --build .\n")),(0,i.kt)("p",null,"Binaries will be available in ",(0,i.kt)("inlineCode",{parentName:"p"},"bin/release-static/")),(0,i.kt)("h2",{id:"ffmpeg-integration"},"FFmpeg Integration"),(0,i.kt)("p",null,"Although not officially supported, you can compile your own FFmpeg binary with ",(0,i.kt)("inlineCode",{parentName:"p"},"libvvenc")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"libvvdec"),". The tutorial can be found in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/fraunhoferhhi/vvenc/wiki/FFmpeg-Integration"},"official VVenC wiki")," (",(0,i.kt)("a",{parentName:"p",href:"https://web.archive.org/web/20230509115800/https://github.com/fraunhoferhhi/vvenc/wiki/FFmpeg-Integration"},"archive"),"), I do not want to include it here because some things change every so often and I'm not paid to keep them updated."),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("p",null,"There are two encoders, the simple encoder (",(0,i.kt)("inlineCode",{parentName:"p"},"vvencapp"),") and the full-featured expert mode encoder (",(0,i.kt)("inlineCode",{parentName:"p"},"vvencFFapp"),") which is based on the VTM configuration scheme (good luck figuring that out). VVenC used to only accept YUV files input until they added Y4M also (Thank the LORD)"),(0,i.kt)("p",null,"!!! YUV vs Y4M\nYUV does not carry any of the original video's metadata, which means you'll have to manually input all the necessary parameters such as frame rates, resolution, bit depth, etc. Y4M takes care all of this\n!!!"),(0,i.kt)("p",null,"A standard input would look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"vvencapp -i input.y4m --qp 20 -o output.266\n")),(0,i.kt)("p",null,"Enhanced, preset slow + qpa + YUV420P10:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"vvencapp -i input.y4m --preset slow --qpa on --qp 20 -c yuv420_10 -o output.266\n")),(0,i.kt)("p",null,"With FFmpeg piping:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"ffmpeg -hide_banner -loglevel error -i input.mkv -pix_fmt yuv420p10le -strict -1 -f yuv4mpegpipe - | vvencapp -i - --y4m --preset medium --qpa on --qp 20 -c yuv420_10 -o output.266\n")),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},"For whatever reason, VVenC currently does not support input resolutions below 540p. Don't know why so ask the devs.")),(0,i.kt)("admonition",{title:"QPA",type:"info"},(0,i.kt)("p",{parentName:"admonition"},'VVenC by default operates with QP (Quantization Parameter), which is basically fixed quality. To enable "CRF-like" mode you need to enable QPA'),(0,i.kt)("p",{parentName:"admonition"},"note for nerds: it modifies the QP both in a spatial and temporal manner combined with temporal RDO.")),(0,i.kt)("h2",{id:"muxing"},"Muxing"),(0,i.kt)("p",null,"Since VVenC only outputs raw ",(0,i.kt)("inlineCode",{parentName:"p"},".266")," bitstream files, you can't just shove audio and subtitle streams in there. Instead you can remux them using ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/gpac/gpac"},"GPAC MP4Box")," ",(0,i.kt)("strong",{parentName:"p"},"nightly/beta/git"),". "),(0,i.kt)("p",null,"You can find all pre-built binaries for Windows, MacOS, and Ubuntu (Linux) right ",(0,i.kt)("a",{parentName:"p",href:"https://gpac.wp.imt.fr/downloads/gpac-nightly-builds"},"here"),", Arch Linux users can find mp4box/GPAC in the AUR, and those who aren't listed here can find the build instructions ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/gpac/gpac/wiki/Build-Introduction"},"here"),". It is recommended to do a minimal build since most of the time you don't really need the extra stuff."),(0,i.kt)("h2",{id:"vvdec"},"VVdeC"),(0,i.kt)("p",null,"VVdeC is the software decoding implementation for decoding/playing VVC files developed by Fraunhofer HHI. All features of the VVC Main10 features are supported."),(0,i.kt)("h3",{id:"installation-1"},"Installation"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Arch Linux users:")," Check AUR."),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Compilation requires CMake")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The following build procedure should work across all common operating systems")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/fraunhoferhhi/vvdec.git\ncd vvdec\nmkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release\ncmake --build .\n")),(0,i.kt)("p",null,"Binaries will be available in ",(0,i.kt)("inlineCode",{parentName:"p"},"bin/release-static/")),(0,i.kt)("h2",{id:"decoding"},"Decoding"),(0,i.kt)("p",null,"There are several ways to decode VVC. One of them made simple by the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/MartinEesmaa/VVCEasy"},"VVCEasy project")," by Martin Eesmaa. Or you can try the manual way by piping into several programs, MP4Box beta/nightly/git, VVdeC, and a video player of choice summonable via CLI (MPV, VLC, ffplay) is required"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"mp4box input.mp4 -raw vvc1:output=temp.266 && vvdecapp -v 0 -b temp.266 -o - | ffmpeg -video_size 1920x804 -framerate 24 -pixel_format yuv420p10le -f rawvideo -i - -i input.mp4 -c copy -map 0:v -map 1:a -f nut - | mpv -\n")),(0,i.kt)("p",null,"Adjust the ",(0,i.kt)("strong",{parentName:"p"},"double")," ",(0,i.kt)("inlineCode",{parentName:"p"},"input.mp4"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-video_size")," for resolution, ",(0,i.kt)("inlineCode",{parentName:"p"},"-framerate"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-pixel_format"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"mpv")," (Video player) accordingly, if not then your video will just play garbled glitches."),(0,i.kt)("admonition",{title:"temp.266",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"You might see a new file appearing called ",(0,i.kt)("inlineCode",{parentName:"p"},"temp.266")," upon running the command, do not panic. This is completely normal as ",(0,i.kt)("inlineCode",{parentName:"p"},"mp4box")," needs to output the raw bitstream so ",(0,i.kt)("inlineCode",{parentName:"p"},"vvdec")," will be able to decode it properly.")))}d.isMDXComponent=!0}}]);