---
title: 无损压缩
sidebar_position: 3
---

# 无损压缩

:::info 维护中
本条目内容不完整，正在完善过程中。
:::

无损压缩是一种数据压缩方法，允许从压缩数据中完美重建原始数据。这在需要完全保留媒体原始保真度的应用中尤为重要，例如存档、通用数据压缩和专业媒体编辑。要理解无损压缩的工作原理，我们首先需要深入理解冗余度、熵值以及无损压缩中常用的特定技术。

### 冗余度与熵值

理解冗余度和熵值这两个概念对后续内容至关重要。

**冗余度**指数据中重复或可预测的元素。这些元素不会增加新信息，可以通过高效编码来减少总体数据量而不丢失任何信息。

**熵值**在信息论中，是衡量数据不可预测性或随机性的指标。较低的熵值意味着较高的冗余度，表明数据在理论上具有更高的可压缩性。

在无损压缩中，目标是根据数据的熵值尽可能减少冗余并进行高效编码。

### 无损压缩技术

1. **游程编码(RLE)**：
   RLE是一种简单的无损压缩形式，将连续相同的数据值（游程）存储为单个数据值和计数。该技术适用于压缩具有长串相同样本的数据，例如静音或恒定音调。例如序列`AAAAABBBCC`可编码为`5A3B2C`。

2. **霍夫曼编码**：
   霍夫曼编码是一种用于无损数据压缩的熵编码算法，通过将输入分解为组成符号并用代码替换每个符号来实现。该算法构建二叉树，每个叶节点代表从输入数据中分离出的符号，从根到叶的路径代表该符号的二进制代码。

   当输入字符的概率分布已知且可利用时，霍夫曼编码非常有效。以交通灯状态存储为例：绿灯50%、红灯40%、黄灯9%、维修关闭1%。虽然可以用两位准确表示所有符号（绿灯`00`、红灯`01`、黄灯`10`、关闭`11`），但通过考虑概率，我们可以减少每个符号的平均比特数：
        - 绿灯(50%)：`0`
        - 红灯(40%)：`11`
        - 黄灯(9%)：`100`
        - 关闭(1%)：`101`

    对应的霍夫曼树如下：

        ![交通灯霍夫曼树](https://raw.githubusercontent.com/av1-community-contributors/images/main/color-huffman-tree-svg.svg)

    计算加权平均比特数：
        (50% • 1) + (40% • 2) + (9% • 3) + (1% • 3) = **1.6**

    最终得到**每个符号平均1.6比特**，显著节省了存储空间。

3. **算术编码**
   算术编码是另一种熵编码技术，将整个消息表示为区间`[0, 1)`内的单个数字。与霍夫曼编码不同，算术编码用单个浮点数*q*表示多个符号，且*q*必须在`0.0 ≤ q < 1.0`范围内。当符号概率分布偏斜时，算术编码比霍夫曼编码更高效，但通常速度较慢。

   仍以交通灯为例：
   - 绿灯：`[0.00, 0.50)`
   - 红灯：`[0.50, 0.90)`
   - 黄灯：`[0.90, 0.99)`
   - 关闭：`[0.99, 1.00)`

   编码序列"绿灯、红灯、黄灯、关闭"的过程：
    1. 初始区间`[0, 1)`
    2. 绿灯：`[0.00, 0.50)`
    3. 红灯：`[0.25, 0.45)`
    4. 黄灯：`[0.43, 0.448)`
    5. 关闭：`[0.44782, 0.448)`

   最终选择区间下限0.44782即可代表整个序列。解码时从该数值出发，根据原始概率范围逆向推导即可还原序列。

   理论上算术编码可达到**1.408比特/符号**的熵值极限：`-(0.50 * log2(0.50) + 0.40 * log2(0.40) + 0.09 * log2(0.09) + 0.01 * log2(0.01)) ≈ 1.408`

   实际应用中还需考虑本简化示例中未涉及的精度管理问题。

4. **预测与残差编码**：
   预测技术利用历史数据预测未来数据，仅编码预测值与实际值的残差。线性预测编码(LPC)是常用方法，通过历史样本的线性函数预测当前样本。残差通常具有更低熵值，可实现更高效编码。